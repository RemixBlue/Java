# 面向对象-final、修饰符、内部类
## 1、final关键字
### 1. 1 概述 
在继承之后子类可以在父类的基础上改写父类内容，比如，方法重写。\
但是不能随意的继承API中提供的类，改写其内容。为了避免这种随意改写的情况，Java提供了 final 关键字， 用于修饰不可改变内容。 
* final： 不可改变。可以用于修饰类、方法和变量。 
    * 被final修饰的类，不能被继承。 
    * 被final修饰的方法，不能被重写。 
    * 被final修饰的变量，不能被重新赋值。
### 1. 2 使用方式
### 修饰类
>格式：
~~~java
final class 类名{
    // 方法体
}
~~~
通过查阅API文档，
> String ：`public final class String ` \
> Scanner ：`public final class Scanner`\
都是被final修饰的，只能使用，不能进行更改其内容。\
被final修饰的类无法被其他类继承。（通常都是定义好的工具类）

### 修饰方法
>格式：
~~~java
修饰符 final 返回值类型 方法名(参数列表){
    // 方法体
}
// 不能重写被final修饰后的方法。子类不可以覆盖重写父类中被final修饰的方法。
~~~
### 修饰变量
1. 局部变量-基本类型
    * 基本类型的局部变量，在被final修饰后，只能赋值一次，赋值后不可更改。
2. 局部变量-引用类型
    * 引用类型的局部变量，在被final修饰后，只能指向一个对象，地址不能更改，但是不影响对象内部成员变量值得更改。
3. 成员变量
    * 构造方法初始化。
    * 显示初始化
    > 被final修饰的常量，在命名时所有字母都必须大写。

---
## 2、权限修饰符
### 2. 1 概述及访问权限 
在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限.
* public：公共的。      （最大权限，在同一类中、同一包中、不同包的类中）
* protected：受保护的   （同一类和同一包中，不同包的子类）
* default：默认的       （同一类哈同一包中）
* private：私有的       （最小权限，同一类中）

编写代码时 ：（建议）
* 成员变量用`private` --> 隐藏细节
* 成员方法用`public` --> 方便调用方法
* 构造方法用`public` --> 方便创建对象
* 不加权限修饰符的，等同于`default`

--- 
## 3、 内部类
### 3. 1 概述 
> 什么是内部类 : 将一个类A定义在另一个类B里面，里面的那个类A就称为内部类，B则称为外部类。 定义内部类非常简单，只要把一个类放入另一个类内部定义即可。

>1、成员内部类 ：定义在类中方法外的类。
* 静态内部类 （使用static修饰）
* 非静态内部类 （不使用static修饰）
>2、局部内部类 ：定义在方法中的类。 

>定义格式：
~~~java 
class 外部类 { 
    class 内部类{

    } 
}
~~~

> 访问特点
* 内部类可以直接访问外部类的成员，包括私有成员。 
* 外部类要访问内部类的成员，必须要建立内部类的对象。
> 创建内部类对象格式：

`外部类名.内部类名 对象名 = new 外部类名().new 内部类名(); `

> 内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的.class文件，但是前面冠以外部类的类名 和$符号 。 比如 : `外部类名$内部类名.class`
### 3. 2 非静态内部类
* 不允许在外部类的静态成员中直接使用非静态内部类。
* Java不允许在非静态内部类中定义静态成员。
    * 非静态内部类里不允许有静态方法、静态成员变量、静态初始化块。
> ps : 非静态内部类里不可以有静态初始化快，但可以包含普通初始化块。非静态内部类普通初始化块的作用与外部类初始化块的作用完全相同。
### 3. 3 静态内部类
如果使用static修饰一个内部类，则这个内部类就属于外部类本身，而不属于外部类的某个对象。因此使用static修饰的内部类被称为类内部类，也称为静态内部类。
* 静态内部类可以包含静态成员，也可以包含非静态成员。
* 静态内部类不能访问外部类的实例成员，只能访问外部类的类成员。
* 静态内部类是外部类的一个静态成员，因此外部类的所有方法，所有初始化块可以使用静态内部类来定义变量和创建对象。

> 扩展理解 ：
> 1. 实例成员：是只有类被实例化后才能使用的成员，包括成员变量和成员方法。
> 2. 类成员：是用static修饰的成员，可以在类不被实例化时，通过类名直接.取使用 
> 3. 接口中也可以定义内部接口。

### 3. 4 使用内部类
1. 在外部类中使用内部类

    * 直接通过内部类类名来定义变量，通过new调用内部类构造器来创建实例化对象。
    * 不要在外部类的静态成员中使用静态成员（包括静态方法和静态初始化代码块）中使用非静态内部类，因为静态成员不能访问非静态成员。
2. 在外部类以外使用非静态内部类
    > 前提 ： 内部类不能使用`private`修饰符，`private`修饰的内部类只能在外部类内部访问。
    * 省略权限修饰符的内部类，只能被与外部类处于同一个包的其他类访问。
    * 使用`protected`修饰的内部类，可被与外部类处于同一个包下的其他类和这个外部类的子类访问。
    * 使用`public`修饰的内部类，可以在任何地方被访问。
> 格式 :
~~~java
// 在外部类以外的地方定义内部类(包括静态和非静态两种)变量的语法格式：
外部类名.内部类名 变量名; // 如果外部类有包名，则应该增加包名前缀

// 在外部类以外的地方创建非静态内部类实例化对象的语法格式：
外部类名.内部类名 对象名 = new 外部类名().new 内部类名();
~~~

3. 在外部类以外的使用静态内部类
>语法格式 ：

`外部类名.内部类名 对象名 = new 外部类名.内部类名(); `

> ps : 继承时，子类不存在重写父类的内部类一说。

### 3. 5 局部内部类
局部内部类 ：定义在方法中的类。 \
因此局部内部类只在方法中有效，不能在外部类的方法以外使用，也不能使用权限修饰符和static特征修饰符。

### 3. 6 匿名内部类【重点】
* 匿名内部类 ：是内部类的简化写法。它的本质是一个 带具体实现的 父类或者父接口的 匿名的 子类对象。

* ### 使用匿名内部类的前提
匿名内部类必须继承一个父类或者实现一个父接口。

> 格式
~~~java
new 父类名或者接口名(){
    // 方法重写 
    @Override 
    public void 方法名() {
        // 执行语句 
    } 
};
~~~
>ps :
* 匿名类不能是抽象类。
* 匿名类不能定义构造器。


> ps : 仅供本人学习使用


# 多线程 - 下

## 主要内容
- 等待与唤醒机制
- 线程池

## **第一章 等待唤醒机制**
## 1. 1 线程间通信
>概念：多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。
* 为什么要处理线程间通信：

    多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当需要多个线程来共同完成一件任务，并且希望多个线程有规律的执行, 那么多线程之间需要一些协调通信，以此来达到多线程共同操作一份数据。
* 如何保证线程间通信有效利用资源：

    多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。就是多个线程在操作同一份数据时，避免对同一共享变量的争夺。也就是需要通过一定的手段使各个线程能有效的利用资源。而这种手段即 —— 等待唤醒机制

## 1. 2 等待唤醒机制
- 什么是等待唤醒机制

    这是多个线程间的一种协作机制。谈到线程便会经常想到的是线程间的竞争（`race`），比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。就是在一个线程进行了规定操作后，就进入等待状态（`wait()`）， 等待其他线程执行完指定代码过后 再将其唤醒（`notify()`）;

    在有多个线程进行等待时， 如果需要，可以使用 `notifyAll()`来唤醒所有的等待线程。`wait/notify` 就是线程间的一种协作机制。
- 等待唤醒中的方法
    等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下：
    1. `wait`：线程不再活动，不再参与调度，进入 `wait set` 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 `WAITING`。它还要等着别的线程执行一个特别的动作，也即是“通知（`notify`）”在这个对象上等待的线程从`wait set `中释放出来，重新进入到调度队列（`ready queue`）中
    2. `notify`：则选取所通知对象的 `wait set` 中的一个线程释放；
    3. `notifyAll`：则释放所通知对象的 `wait set `上的全部线程。
>注意：

哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以它需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调
用 wait 方法之后的地方恢复执行。
- 总结如下：

如果能获取锁，线程就从 `WAITING` 状态变成 `RUNNABLE` 状态；
否则，从 `wait set` 出来，又进入 `entry set`，线程就从 `WAITING` 状态又变成 `BLOCKED` 状态
- 调用`wait`和`notify`方法需要注意的细节
1. `wait`方法与`notify`方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过`notify`唤醒使用同一个锁对象调用的`wait`方法后的线程。
2. `wait`方法与`notify`方法是属于`Object`类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了`Object`类的。
3. `wait`方法与`notify`方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。
---
## **第二章 线程池**
## 2. 1 线程池概念
> 线程池：其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。
- 合理利用线程池能够带来三个好处：
    1. 降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。
    2. 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
    3. 提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。
## 2. 2 线程池的使用
Java里面线程池的顶级接口是 `java.util.concurrent.Executor` ，但是严格意义上讲 `Executor` 并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是 `java.util.concurrent.ExecutorService` 。

要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在 `java.util.concurrent.Executors` 线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。官方建议使用`Executors`工程类来创建线程池对象。

- `Executors`类中有个创建线程池的方法如下：
    - `public static ExecutorService newFixedThreadPool(int nThreads)` ：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量)
- 使用线程池：
- `public Future<?> submit(Runnable task)` :获取线程池中的某一个线程对象，并执行
>`Future`接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。

>使用线程池中线程对象的步骤：
1. 创建线程池对象。
2. 创建Runnable接口子类对象。
3. 提交Runnable接口子类对象。
4. 关闭线程池(一般不做)。

---
> ps : 仅供本人学习使用
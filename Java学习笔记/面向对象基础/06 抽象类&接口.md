# 面向对象-抽象类&接口
## 1、 抽象类
### 1. 1 概述
父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有 意义，而方法主体则没有存在的意义了。我们把没有方法主体的方法称为抽象方法。Java语法规定，包含抽象方法 的类就是抽象类。
#### 定义
* 抽象方法 ：没有方法体的方法。 
* 抽象类：包含抽象方法的类。

### 1. 2 abstract使用格式 
* 抽象方法 :\
使用 abstract 关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。
> 定义格式 ：

`修饰符 abstract 返回值类型 方法名 (参数列表);`

> 代码举例 ：

`public abstract void run();`

* 抽象类：\
如果一个类包含抽象方法，那么该类就必须是一个抽象类。

> 定义格式 ： 

~~~java
abstract class 类名称{
    // ...
}
~~~
> 代码举例 ：
~~~java
public abstract class Remix{
    public abstract void run();
}
~~~

### 1. 3抽象类的使用
>因为抽象类本身被设计成只能用于被继承而不能实例化，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”。
    
>继承抽象类的子类必须重写父类所有的抽象方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该父类的抽象方法，否则，从最初的父类到最终的子类都不能创建对象，失去意义。
>> 方法重写，是子类对父类抽象方法的完成实现，这种方法重写的操作，也叫做实现方法。

### 1. 4 注意事项
1. 抽象类必须使用 abstract 修饰符来修饰，抽象方法也必须使用 abstract 修饰符来修饰，抽象方法不能有方法体。
2. 抽象类不能创建实例化对象，只能通过非抽象子类继承重写父类的抽象方法后创建子类的实例化对象。
3. 抽象类不一定包含抽象方法，但包含抽象方法的类必须是抽象类。
4. 抽象类的非抽象子类必须重写父类的所有抽象方法，抽象子类不用。
5. 抽象类可以包含成员变量、方法（普通方法和抽象方法都可以）、构造器、初始化块、内部类（接口、枚举）5种部分。
6. 抽象类可以有构造方法，仅供子类创建实例化对象时，初始化父类成员使用的。
    * 子类的构造方法中，有默认的super(),需要访问父类的构造方法。

---
## 2、接口
### 2. 1概述
#### 概述 ：
抽象类是从多个类中抽象出来的模板，如果将这种抽象进行的更彻底，则可以提炼出一种更加特殊的“抽象类”————接口（interface）。\
接口的内部主要就是封装了方法，包含抽象方法，默认方法，静态方法，私有方法。
#### 用途： 
1. 定义变量
2. 调用接口中定义的变量
3. 被其他类实现
> ps : 一个类可以是实现一个或多个接口，继承使用关键字`extends`,实现则使用`implements`关键字

### 2. 2 接口的定义
与类定义相似但有不同，类定义使用的是class ，而订单一接口时使用的是 interface 。
> 接口的定义格式 ：
~~~java
// 定义接口
// 一个接口可以有零到多个父接口，但接口只能继承接口，不能继承类。
[修饰符] interface 接口名 {
    // 静态常量
    // 抽象方法 
    // 默认方法
    // 静态方法
    // 私有方法
}
// 静态常量: 使用public static final修饰符，定义的时候必须赋值。
    public static final 数据类型 常量名 = 值;
// 抽象方法：使用 abstract 关键字修饰，可以省略，没有方法体。该方法供子类实现使用。
    public abstract void 抽象方法名(); // 没有花括号方法体
// 默认方法：使用 default 修饰，不可省略，供子类调用或者子类重写。 
    public default void 默认方法名() { 
        // 执行语句 
    }
// 静态方法：使用 static 修饰，供接口直接调用。
    public static void 静态方法名() {
        // 执行语句 
    }
// 私有方法：使用 private 修饰，供接口中的默认方法或者静态方法调用。
    private void 私有方法名() {
        // 执行语句 
    }
~~~
### 2. 3 接口的实现
>* 实现的概述：

类与接口的关系不是继承关系而是实现关系，即【类实现接口】，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 implements 关键字。

>* 非抽象子类实现接口： 
1. 必须重写接口中所有抽象方法。 
2. 继承了接口的默认方法，即可以直接调用，也可以重写。
> 实现格式 ：
~~~java
[修饰符] class 类名 implements 接口1 , 接口2 ... { 
    // 重写接口中抽象方法【必须】 
    // 重写接口中默认方法【可选】 
}
// 抽象方法的实现
// 必须全部实现（重写全部的抽象方法）使用 @Override

// 默认方法的实现
// 可以继承，可以重写，二选一，但是只能通过实现类的对象进行调用。
// 1、 默认继承，神魔都不用写。
// 2、 重写默认方法 使用 @Override

// 静态方法的实现
// 静态与.class 文件相关，只能使用接口名调用，不可以通过实现类的类名或者实现类的对象调用
// 无法重写静态方法。

// 私有方法的实现
// 1、私有方法：只有默认方法可以调用。 
// 2、私有静态方法：默认方法和静态方法可以调用。
/*
如果一个接口中有多个默认方法，并且方法中有重复的内容，那么可以抽取出来，封装到私有方法中，供默认方法 去调用。从设计的角度讲，私有的方法是对默认方法和静态方法的辅助。
*/
~~~
### 2. 4 接口的多实现
在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接 口的多实现。并且，一个类能继承一个父类，同时实现多个接口。

> 实现格式 ：
~~~java
[修饰符] class 类名 [extends 父类名] implements 接口1 , 接口2 ... { 
    // 重写接口中抽象方法【必须】 
    // 重写接口中默认方法【可选】

/* 
抽象方法 ：
接口中，有多个抽象方法时，实现类必须重写所有抽象方法。如果抽象方法有重名的，只需要重写一次。

默认方法 ： 
接口中，有多个默认方法时，实现类都可继承使用。如果默认方法有重名的，必须重写一次。

静态方法 ：
接口中，存在同名的静态方法并不会冲突，原因是只能通过各自接口名访问静态方法。

优先级的问题 ：
当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类就近选择执行继承父类的成员方法。
*/
}
~~~
> [ ]： 表示可选操作。

### 2. 5 接口的多继承【了解】 
一个接口能继承另一个或者多个接口，这和类之间的继承比较相似。接口的继承使用 extends 关键字，子接口继承父接口的方法。如果父接口中的默认方法有重名的，那么子接口需要重写一次。

>注意 : 
* 子接口重写默认方法时，default关键字可以保留。 
* 子类重写默认方法时，default关键字不可以保留。
* 接口中，无法定义成员变量，但是可以定义常量，其值不可以改变，默认使用public static final修饰。 
* 接口中，没有构造方法，不能创建对象。 
* 接口中，没有静态代码块。
* 接口也是数据类型，适用于向上转型和向下转型。

---
## 扩展
### 接口与抽象类
* 接口和抽象类都不能被实例化，它们都位于继承数的最顶端，用于被其他类实现或继承
* 接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类，都必须实现这些抽象方法。
* 接口里只包含抽象方法、静态方法、默认方法和私有方法，不能为普通方法提供方法实现；抽象类则完全可以包含普通方法。
* 接口只能定义静态常量，不能定义普通成员变量；抽象类里即可以定义普通成员变量，也可以定义静态常量。
* 接口里不包含构造方法，抽象类里包含构造方法，但抽象类里的构造方法并不用于创建实例化对象，而是让其子类调用这些构造方法来完成属于抽象类的初始化操作。
* 接口里不能包含初始化块；抽象类里完全可以包含初始化块。
* 一个类最多只能有一个直接父类，包括抽象类。但一个类可以直接实现多个接口，通过实现多个接口，来弥补Java单继承的不足。



> ps : 仅供本人学习使用
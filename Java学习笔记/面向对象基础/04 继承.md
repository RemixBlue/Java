# 面向对象-继承
## 继承
### 1. 1 概述
#### 定义继承 ：
    就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接 访问父类中的非私有(public protected)的属性和方法(行为)。 
> 好处 ：
1. 提高代码的复用性。 
2. 类与类之间产生了关系，是【多态】的前提。

### 1.2 继承的格式 
Java使用extends关键字来实现继承，可以声明一个子类继承另外一个父类\
> 定义格式：
~~~java
class 父类 {
     // 代码块 
}
class 子类 extends 父类 {
     // 代码块
}
~~~
### 1.3 继承后成员变量
* 成员变量不重名   
     如果子类父类中出现不重名的成员变量，这时的访问是没有影响的。
* 成员变量重名 \
    如果子类父类中出现重名的成员变量，这时的访问是有影响的。
    > 子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用 super 关键字，修饰 父类成员变量，类似于 this 。
    >
    > 使用格式：\
    >`super.父类成员变量名`
### 1.4 继承后的成员方法
* 成员方法不重名\
    如果子类父类中出现不重名的成员方法，这时的调用是没有影响的。对象调用方法时，会先在子类中查找有没有对 应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。
* 成员方法重名——重写(Override)\
        如果子类父类中出现重名的成员方法，这时的访问是一种特殊情况，叫做方法重写 (Override)。

   > 重写示例：

~~~java
class 父类 { 
    public void 方法一() {
        System.out.println("父类的方法一"); 
    } 
 }
class 子类 extends 父类 {
    //子类重写了父类的方法一 
    public void 方法一() {
    super.方法一;
    System.out.println("子类重写父类后的方法一"); 
    } 
}
public class 主类{
    public static void main(String[] args) {
        子类名 子类对象名 = new 子类名();
        // 子类中有方法一，只执行重写后的方法一 
        子类对象名.方法一(); // 子类重写父类后的方法一 
    } 
}
~~~
> 重写时，用到`super.父类成员方法`，表示调用父类的成员方法。
#### 注意事项 ： 
1. 子类方法覆盖重写父类方法，必须要保证权限大于等于父类权限。 
2. 子类方法覆盖重写父类方法，返回值类型、函数名和参数列表都要一模一样。
3. 子类可以添加自己独有的属性和方法的

### 1.5 继承后的构造方法
#### 构造方法的定义格式和作用 :
1. 构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法的。 
2. 构造方法的作用是初始化成员变量的。所以子类的初始化过程中，必须先执行父类的初始化动作。子类的构 造方法中默认有一个 `super();` ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用。
### 1.6 super和this
* super和this的含义 \
super ：当需要在子类中调用父类的被重写方法时，要使用super关键字。 (可以理解为父亲的引用)。 \
this ：代表当前对象的引用(谁调用就代表谁)。 
* super和this的用法 
1. 访问成员
2. 访问构造方法 
    >子类的每个构造方法中均有默认的`super()`，调用父类的空参构造。手动调用父类构造会覆盖默认的`super()`。 `super()` 和 `this()` 都必须是在构造方法的第一行(以分号 ; 为准)，所以不能同时出现。

### 1. 7 继承特点 
* Java只支持单继承（继承基本类和抽象类），所有类最终的根类是Object。
* 子类和父类是一种相对的概念。
* 但是Java支持多层继承（继承体系）。
* 也可以用接口来实现（多继承接口来实现）\
`public class 子类 extends 父类 implements 接口1, 接口2{}`
---
## Java 重写(Override)与重载(Overload)
* 重写(Override) 
    * 子类可以根据自身实际需要，对父类方法进行重写，重写时，返回值和形参都不能改变。
* 重载(Overload)
    * 重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。
    * 每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。
    * 只能重载构造方法（每个构造方法的参数都不一样）
> 方法重写的规则 :
    >>* 参数列表必须完全与被重写方法的相同；
    >>* 返回类型必须完全与被重写方法的返回类型相同；
    >>* 子类方法的访问权限必须大于或等于父类方法的访问权限。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。
    >>* 父类的成员方法只能被它的子类重写。
    >>* 声明为final的方法不能被重写。
    >>* 声明为static的方法不能被重写，但是能够被再次声明。
    >>* 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。
    >>* 子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。
    >>* 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。
    >>* 构造方法不能被重写。
    >>* 如果不能继承一个方法，则不能重写这个方法。

> 重载规则 ：
    >>* 被重载的方法必须改变参数列表；
    >>* 被重载的方法可以改变返回类型；
    >>* 被重载的方法可以改变访问修饰符；
    >>* 被重载的方法可以声明新的或更广的检查异常；
    >>* 方法能够在同一个类中或者在一个子类中被重载。

> 重写与重载之间的区别 :

|区别点|重载方法|重写方法|
|:---|:---:|---:|
|参数列表|必须修改|一定不能修改|
|返回类型|可以修改|一定不能修改|
|异常|可以修改|可以减少或删除，一定不能抛出新的或者更广的异常|
|访问|可以修改|一定不能做更严格的限制（可以降低限制）|

> ps : 仅供本人学习使用